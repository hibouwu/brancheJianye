# Shadow 框架包名整理

## 一、宿主应用 (VersionPlugin)

- **applicationId**: `descartes.info.l3p2`
- **主 Activity**: `descartes.info.l3p2.MainActivity`
- **代理 Activity** (AndroidManifest.xml 中声明):
  - `com.tencent.shadow.sample.runtime.PluginDefaultProxyActivity`

## 二、插件应用 (plugin-project/app)

- **applicationId**: `descartes.info.l3p2` (与宿主相同)
- **namespace**: `descartes.info.l3p2.eyetrek.reconnaissanceArbres`
- **AndroidManifest.xml 中包名**: `descartes.info.l3p2.eyetrek.reconnaissanceArbres`
- **插件 Activity**: `descartes.info.l3p2.eyetrek.reconnaissanceArbres.activity.Activity`

## 三、运行时库 (plugin-project/sample-runtime)

- **applicationId**: `com.tencent.shadow.sample.runtime`
- **代理 Activity**: `com.tencent.shadow.sample.runtime.PluginDefaultProxyActivity`

## 四、加载器 (plugin-project/sample-loader)

- **applicationId**: `com.tencent.shadow.sample.loader`
- **组件管理器**: `com.tencent.shadow.sample.loader.SampleComponentManager`
- **插件加载器**: `com.tencent.shadow.sample.loader.SamplePluginLoader`

## 五、插件管理器 (PluginManager)

- **包名**: `descartes.info.pluginmanager`
- **主类**: `descartes.info.pluginmanager.MyPluginManager`
- **服务名**: `descartes.info.l3p2.service.MainPluginProcessService`

## 六、重要流程和对应的类名

### 插件加载流程

1. 宿主调用 `descartes.info.l3p2.MainActivity.startPlugin()`
2. 启动插件管理器 `descartes.info.pluginmanager.MyPluginManager`
3. 加载运行时和加载器 APK:
   - 运行时: `com.tencent.shadow.sample.runtime`
   - 加载器: `com.tencent.shadow.sample.loader`
4. 使用加载器加载插件 APK
5. 转换插件 Activity 为代理 Activity:
   - 插件 Activity: `descartes.info.l3p2.eyetrek.reconnaissanceArbres.activity.Activity`
   - 代理 Activity: `com.tencent.shadow.sample.runtime.PluginDefaultProxyActivity`
6. 启动代理 Activity

### 出现的问题

1. 宿主 AndroidManifest.xml 中声明的代理 Activity 为 `com.tencent.shadow.sample.runtime.PluginDefaultProxyActivity`
2. 运行时实际加载的代理 Activity 也是 `com.tencent.shadow.sample.runtime.PluginDefaultProxyActivity`
3. 但系统找不到这个类，提示 `ClassNotFoundException`

## 七、问题分析和解决方案

问题在于 Shadow 框架的工作机制：
- 代理 Activity 必须在宿主 AndroidManifest.xml 中声明
- 但代理 Activity 的实现是在运行时动态加载的
- 如果运行时库没有正确加载，或者代理 Activity 的路径不匹配，就会出现 `ClassNotFoundException`

解决方案:
1. 确保运行时库 (`sample-runtime-debug.apk`) 正确构建
2. 确保运行时库被正确复制到宿主可访问的位置
3. 确保运行时库的加载成功 (检查日志中是否有 `loadRunTime` 成功)
4. 确保宿主 AndroidManifest.xml 中声明的代理 Activity 与运行时库中的实际类路径完全一致 